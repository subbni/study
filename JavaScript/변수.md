# 변수

## 변수란?
하나의 값을 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

자바스크립트의 변수 키워드에는 var, let, const 총 3가지가 존재한다.

---


## var
var은 ES6에서 let, const가 도입되기 전까지 JS에서 유일하게 변수를 선언할 수 있었던 키워드이다.

### 변수 중복 선언 허용

var 키워드로 선언된 변수는 중복 선언이 가능하다.
- 초기화문이 있는 중복 변수 선언문(ex.`var x = 10`)은 앞의 var 키워드가 없는 것처럼 동작하여 단순 값의 재할당이 일어난 것처럼 동작한다.
- 초기화문이 없는 중복 변수 선언문(ex. `var x;`)은 그냥 무시된다.

```js
var x = 1;

var x = 10;
var x;

console.log(x); // 10
```

### 함수 레벨 스코프
var 키워드로 선언된 변수는 오직 함수의 코드 블록만을 지역 스코프로 인정한다.
따라서 함수의 코드 블록 이외에서 var 키워드로 선언된 모든 변수는 전역 변수가 된다.
```js
var i = 1;

for(var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 4
```

### 변수 호이스팅

var 키워드로 선언된 변수는 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작한다.
즉, JS 엔진은 한 스코프 내의 소스코드를 순차적으로 실행하기에 앞서 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.

> 변수 호이스팅: 변수 선언문이 코드의 선두로 끌어올려진 것 처럼 동작하는 자바스크립트 고유의 특징이다.

이 때, var 키워드의 경우 변수 호이스팅 시 __변수의 선언과 함께 `undefined`로의 초기화가 동시에 진행된다.__
```js
console.log(x); // ① undefined

var x = 10;

console.log(x); // ② 10
```

따라서 실제로 코드에서 값의 할당이 이루어지기 전까지 x를 참조하면 언제나 undefined를 반환하게 된다.
변수에 값이 할당되면, 저장할 메모리 공간을 확보하고 그 곳에 할당 값을 저장한 뒤 해당 메모리 주소를 변수가 참조하도록 한다.

### 전역 객체
var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다.
```js
var x = 1;
y = 2;
function sayHello() {
  console.log('hello');
};

console.log(window.x); // 1
console.log(window.y); // 2
console.log(window.sayHello()); // hello
```

---

## let

let 키워드는 ES6에서 새롭게 추가된 변수 선언 키워드이다.
(Java에서의 일반 변수와 동일하게 동작한다고 생각하면 될 것 같다.)

### 변수 중복 선언 불가

let 키워드로 이름이 같은 변수를 중복 선언하면, 에러가 발생한다.
```js
let x = 1;

let x = 10; // SysntaxError: Identifier 'x' has already been declared.
```

### 블록 레벨 스코프

var 키워드와 달리, 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 가진다.
```js
let i = 1;

for(let i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 1
```

### 변수 호이스팅

let 키워드로 선언된 변수 역시 변수 호이스팅이 실행된다.

그렇지만 var 키워드와 달리, 변수 호이스팅이 일어나지 않는 것처럼 동작한다. 
그 이유는 __변수 호이스팅시 변수의 선언만 이루어지고 `undefined`로의 초기화가 이루어지지 않기 때문이다.__

선언 단계에서 스코프에 변수 식별자를 등록하여 변수의 존재를 알린다. 
하지만 초기화가 이루어지지 않아 실제 선언문을 평가하기 전까지 해당 변수는 없는 것처럼 동작하여, 참조 시 에러를 발생한다.
```js
console.log(x); // ReferenceError: x is not defined.

let x; // 변수 선언문에서 초기화가 진행된다. 

console.log(x); // undefined

x = 10;

console.log(x); // 10
```

그렇지만 변수 호이스팅이 일어나지 않는 것과는 분명한 차이가 있다.

```js
let x = 10;
{
  console.log(x);
  let x = 100;
}
```

만일 변수 호이스팅이 일어나지 않는다면, 위 코드의 실행결과는 10이 될 것이다.

그렇지만 JS엔진은 지역 스코프의 코드들을 순차적으로 평가하기 직전에 변수 선언문을 찾아내어 변수 식별자를 등록한다.
따라서 위 코드의 실행 결과 `ReferenceError`가 발생하게 된다.

---

## const

const 키워드는 let과 유사하나, 주로 상수를 선언하기 위해 사용된다. 몇 가지 이외에는 let 키워드와 동일하게 동작한다.

### 선언과 초기화
const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화, 값의 할당을 해주어야 한다.
```js
const foo; // SyntaxError: Missing Initializer in const declaration
```

### 재할당 금지
const 키워드로 선언된 변수에는 값의 재할당이 금지된다.
```js
const foo = 1;
foo = 2; // TypeError: Assignment to constant variable.
```

즉, 해당 변수가 참조하고 있는 값을 변경하는 것이 불가능하다는 의미이다.

객체의 경우 객체의 내용을 변경하는 것은 허용된다. 변수 선언 시 객체를 할당받은 변수는 객체가 저장된 메모리 힙의 `주소`를 참조하고 있기 때문이다.

따라서 아예 새로운 객체를 참조하는 것은 금지되지만, 객체의 프로퍼티를 변경하는 것은 변수에 할당된 참조 값에 아무런 변화를 일으키지 않으므로 가능하다.

> 이외의 블록 레벨 스코프, 변수 호이스팅은 let과 동일하게 동작한다.


