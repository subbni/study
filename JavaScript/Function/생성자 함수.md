# 생성자 함수

객체 리터럴을 통한 객체 생성 방식은 단 하나의 객체만 생성한다.
따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.

생성자 함수에 의한 객체 생성 방식은 객체(인스턴스)를 만들기 위한 틀(클래스)처럼 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

생성자 함수는 말 그대로 객체를 생성하는(Java에서 클래스의 기능) 함수이다.

- 일반함수와 동일하게 정의하여 앞에 new 연산자와 함께 호출해주면 해당 함수는 생성자 함수로 동작한다.
- 만일 new 연산자와 함께 호출하지 않으면 일반 함수로서 호출된다.
> 일반 함수와 생성자 함수 간의 특별한 형식적 차이는 없다. 따라서 생성자 함수는 일반적으로 파스칼 케이스로 이름지어(첫 문자가 대문자가 됨) 일반 함수와 구별할 수 있게 한다.

## 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
암묵적으로 빈 객체가 생성되어 생성자 함수 내부의 `this`에 바인딩된다. 

이 처리는 함수 몸체의 코드가 실행되는 런타임 이전에 실행된다.
따라서 런타임에 `this`를 참조하면, 해당 생성자 함수가 반환할 인스턴스를 가르키게 된다.

2. 인스턴스 초기화
생성자 함수에 기술된 코드가 실행되어 인스턴스를 초기화하는 작업이 수행된다.

이 때 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당하는 등, 개발자의 처리가 이루어진다.

3. 인스턴스 반환
생성자 함수 내부의 모든 처리가 끝나면 인스턴스가 바인딩된 `this`를 암묵적으로 반환한다.

이 때, 만약 다른 객체를 명시적으로 반환하는 return 문이 존재한다면 `this`가 아닌 명시된 객체가 반환된다.
> 명시적으로 원시 값을 반환하는 경우 : 해당 return 문은 무시되며, this가 암묵적으로 반환된다.

## [[Call]] 과 [[Construct]]
함수는 일반 객체가 가지지 않은 `[[Call]]` , `[[Construct]]` 내부 메서드를 추가로 가지고 있다.
(이 외에도 일반 객체가 가지지 않은 내부 슬롯/메서드를 가짐)

- 함수가 일반 함수로서 호출되면 함수 객체 내부 메서드 `[[Call]]`이 호출된다.
- 함수가 new 연산자와 함께 호출되면 함수 객체 내부 메서드 `[[Construct]]`가 호출된다.

- 내부 메서드 `[[Call]]`을 갖는 함수 객체를 callable이라 한다.
- 내부 메서드 `[[Construct]]`를 갖는 함수 객체를 constructor라고 한다.

함수 객체는 반드시 callable이지만, 모든 함수 객체가 constructor인 것은 아니다.

즉, 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 사용할 수 있는 것은 아니다.

## constructor와 non-constructor

JS엔진은 함수 객체를 생성할 때의 함수 정의 방식에 따라 constructor/non-constructor를 구분한다.

- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수

```js
function foo() {} // 함수 선언문
const bar = function () {} // 함수 표현식
const baz = {
  x : function() { } // 일반 함수로 정의된 함수, 메서드 X
};

new foo(); // foo {}
new bar(); // bar {}
new baz.x(); // x {}
```

```js
const arrow = () => {}; // 화살표 함수
const obj = {
  x() {}
};

new arrow(); // TypeError : arrow is not a constructor
new obj.x(); // TypeError : obj.x is not a constructor
```

함수를 프로퍼티 값으로 사용하면 일반적으로 메서드라고 통칭한다. 하지만 ECMAScript 사양에서 메서드란 ES6의 메서드 축약 표현만을 의미한다.

즉, 함수가 어디에 할당되어 있는지가 아니라 함수 정의 방식에 따라 constructor / non-constructor를 구분한다.

## new.target
생성자 함수가 new 연산자 없이 일반 함수로 호출되는 것을 막기 위해 ES6에서 `new.target`을 지원한다.
- new 연산자와 함께 생성자 함수로서 호출된다면 `new.target`은 함수 자신을 가리킨다.
- new 연산자 없이 일반 함수로서 호출된다면 `new.target`은 `undefined` 값을 가진다.

```js
function Person(name) {
  if(!new.target) {
    return new Person(name);
  }
}
```
이런 식으로 new 연산자를 사용하여 호출되었는지를 확인하고, 그렇지 않은 경우 new 연산자를 사용하여 재귀 호출함으로써 생성자 함수로서만 기능할 수 있도록 설정할 수 있다.

> new.target은 ES6에서 도입한 최신 문법으로 IE에서는 지원하지 않는다. 이 경우 스코프 세이프 생성자 패턴을 사용하면 된다.


